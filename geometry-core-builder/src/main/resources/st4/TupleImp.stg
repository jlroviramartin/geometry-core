delimiters "$", "$"

import "Common.stg"

TupleImp(desc) ::= <<
package $desc._package$;

import java.util.logging.Level;
import java.util.logging.Logger;
import essence.util.math.EpsilonEquatable;
import essence.util.math.$desc.type$s.MathUtils;
import essence.geometry.core.VectorFormatInfo;
import $desc.corePackage$.Tuple$desc.dim$;
import $desc.corePackage$.Tuple$desc.dim$_Number;
import $desc.corePackage$.BuffTuple$desc.dim$_Number;

import static essence.util.math.$desc.type$s.MathUtils.EPSILON;

/**
 * Basic implementation of {@code Tuple$desc.dim$\} and {@code Tuple$desc.dim$_$desc.ctype$\}.
 */
public class Tuple$desc.dim$$desc.suffix$ implements Tuple$desc.dim$, Tuple$desc.dim$_$desc.ctype$, EpsilonEquatable<Tuple$desc.dim$> {

$TupleImp_Fields(desc)$

$TupleImp_Constructors(desc, {Tuple$desc.dim$$desc.suffix$})$

$TupleImp_Public(desc)$

$TupleImp_Private(desc)$

$TupleImp_Object(desc)$

$TupleImp_Tuple(desc)$

$TupleImp_Tuple_Number(desc)$

$TupleImp_Tuple_Type(desc)$

$TupleImp_EpsilonEquatable(desc)$
}
>>

TupleImp_Fields(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="fields">
$desc.properties :{ property |
    /** $property.upperName$ coordinate. */
    private final $property.type$ $property.name$;
}$
    private static final Logger LOG = Logger.getLogger(Tuple$desc.dim$$desc.suffix$.class.getName());
    private static String format;
//</editor-fold>
>>

TupleImp_Constructors(desc, className) ::= <<
    /**
     * Empty constructor.
     */
    public $className$() {
        this($desc.properties :{ property | 0}; separator=", "$);
    }

    /**
     * This constructor sets the ( $desc.properties :{ property | $property.upperName$}; separator=", "$ ) coordinates.
     *
     $desc.properties :{ property | * @param $property.name$ Value of the property $property.upperName$. }; separator="\n"$
     */
    public $className$($desc.properties :{ property | $property.type$ $property.name$}; separator=", "$) {
$desc.properties :{ property |
        this.$property.name$ = $property.name$;
}$
    }

    /**
     * Copy constructor.
     *
     * @param other Other tuple.
     */
    public $className$(Tuple$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
$desc.properties :{ property |
        this.$property.name$ = _other.get$property.upperName$();
}$
    }
>>

TupleImp_Public(desc) ::= <<
    /**
     * This method gets the coordinate {@code i} of {@code this} tuple.
     *
     * @param i Coordinate index.
     * @return Coordinate.
     */
    public $desc.type$ getItem(int i) {
        switch (i) {
$desc.properties :{ property |
            case $property.index$: return $property.name$;
}$
        }
        throw new IndexOutOfBoundsException();
    }

    /**
     * This method converts {@code this} tuple to a {@code $desc.type$} array.
     *
     * @return Array.
     */
    public $desc.type$[] toArray() {
        return new $desc.type$[]{$desc.properties :{ property | $property.name$}; separator=", "$};
    }

    /**
     * This method tests if {@code this} tuple constains any NaN coordinate.
     *
     * @return True if it constains any NaN coordinate. False otherwise.
     */
    public boolean isNaN() {
        return $desc.properties :{ property | MathUtils.isNaN($property.name$)}; separator=" || "$;
    }
>>

TupleImp_Private(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="private">
    private boolean epsilonEquals($desc.properties :{ property | $property.type$ $property.name$}; separator=", "$) {
        return this.epsilonEquals($desc.properties :{ property | $property.name$}; separator=", "$, EPSILON);
    }

    private boolean epsilonEquals($desc.properties :{ property | $property.type$ $property.name$}; separator=", "$, double epsilon) {
        return $desc.properties :{ property | MathUtils.epsilonEquals(this.$property.name$, $property.name$, epsilon)}; separator=" && "$;
    }

    private boolean equals($desc.properties :{ property | $property.type$ $property.name$}; separator=", "$) {
        return $desc.properties :{ property | (this.$property.name$ == $property.name$)}; separator=" && "$;
    }

    private Tuple$desc.dim$_$desc.ctype$ toTuple(Tuple$desc.dim$ other) {
        if (other instanceof Tuple$desc.dim$_$desc.ctype$) {
            return (Tuple$desc.dim$_$desc.ctype$)other;
        }
        if (other instanceof Tuple$desc.dim$_Number) {
            BuffTuple$desc.dim$$desc.suffix$ aux = new BuffTuple$desc.dim$$desc.suffix$();
            ((Tuple$desc.dim$_Number)other).get(aux);
            return aux;
        }
        throw new essence.geometry.core.ConvertError();
    }

    private static String getFormat() {
        if (format == null) {
            String f = ".3f";

            StringBuilder buff = new StringBuilder();
            String b = "%1\$s";
            String s = "%2\$s";
            String e = "%3\$s";
            int k = 4;
            buff.append(b);

$desc.properties :{ property |
            buff.append("%").append(k++).append("\$").append(f);
}; separator="            buff.append(s); "$
            buff.append(e);
            format = buff.toString();
        }
        return format;
    }
//</editor-fold>
>>

TupleImp_Object(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="object">
    @Override
    public String toString() {
        VectorFormatInfo vfi = VectorFormatInfo.CURRENT_INFO;
        return String.format(getFormat(), vfi.getBeg(), vfi.getSep(), vfi.getEnd(), $desc.properties :{ property | get$property.upperName$()}; separator=", "$);
    }

    public boolean equals(Tuple$desc.dim$ other) {
        if (other == this) {
            return true;
        }
        if (other == null) {
            return false;
        }
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
        return this.equals($desc.properties :{ property | _other.get$property.upperName$()}; separator=", "$);
    }

    @Override
    public boolean equals(Object other) {
        return ((other instanceof Tuple$desc.dim$) && this.equals((Tuple$desc.dim$) other));
    }

    @Override
    public int hashCode() {
        // https://stackoverflow.com/questions/113511/best-implementation-for-hashcode-method
        //return Objects.hash($desc.properties :{ property | $property.name$}$);
        // http://www.jarvana.com/jarvana/view/org/apache/lucene/lucene-spatial/2.9.3/lucene-spatial-2.9.3-sources.jar!/org/apache/lucene/spatial/geometry/shape/Vector2D.java
        final int prime = 31;
        int hash = 1;
$desc.properties :{ property |
        hash = prime * hash + $desc.ctype$.hashCode($property.name$);
}$
        return hash;
    }

    @Override
    public Tuple$desc.dim$$desc.suffix$ clone() {
        Tuple$desc.dim$$desc.suffix$ copy;
        try {
            copy = (Tuple$desc.dim$$desc.suffix$) super.clone();
        }
        catch (CloneNotSupportedException ex) {
            LOG.log(Level.SEVERE, null, ex);
            copy = new Tuple$desc.dim$$desc.suffix$();
        }
        return copy;
    }
//</editor-fold>
>>

TupleImp_Tuple(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="Tuple$desc.dim$">
    @Override
    public boolean isValid() {
        return $desc.properties :{ property | MathUtils.isValid($property.name$)}; separator=" && "$;
    }

    @Override
    public boolean isInfinity() {
        return $desc.properties :{ property | MathUtils.isInfinite($property.name$)}; separator=" && "$;
    }

    @Override
    public boolean isZero() {
        return epsilonEquals($desc.properties :{ property | 0}; separator=", "$);
    }
//</editor-fold>
>>

TupleImp_Tuple_Number(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="Tuple$desc.dim$_Number">
    /**
     * This method sets the values of {@code this} tuple into {@code buff}.
     *
     * @param buff Where to put the values.
     */
     @Override
    public void get(BuffTuple$desc.dim$_Number buff) {
        buff.set$desc.ctype$($desc.properties :{ property |get$property.upperName$()}; separator=", "$);
    }
//</editor-fold>
>>

TupleImp_Tuple_Type(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="Tuple$desc.dim$_$desc.ctype$">
$desc.properties :{ property |
    @Override
    public $property.type$ get$property.upperName$() {
        return $property.name$;
    \}
}; separator="\n"$//</editor-fold>
>>

TupleImp_EpsilonEquatable(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="EpsilonEquatable<Tuple$desc.dim$>">
    @Override
    public boolean epsilonEquals(Tuple$desc.dim$ other, double epsilon) {
        if (other == this) {
            return true;
        }
        if (other == null) {
            return false;
        }
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
        return epsilonEquals($desc.properties :{ property | _other.get$property.upperName$()}; separator=", "$, epsilon);
    }
//</editor-fold>
>>
