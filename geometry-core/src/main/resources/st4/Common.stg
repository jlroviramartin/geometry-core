delimiters "$", "$"

UnaryOperator(desc, op, this, baseType ="Vector") ::= <<
return new $baseType$$desc.dim$$desc.suffix$($desc.properties :{ property
    |$op$ $this$get$property.upperName$()}; separator=", "$);
>>

UnaryFunction(desc, op, this, baseType ="Vector") ::= <<
return new $baseType$$desc.dim$$desc.suffix$($desc.properties :{ property
    |$op$($this$get$property.upperName$())}; separator=", "$);
>>

BinaryOperator(desc, op, this, other, baseType ="Vector") ::= <<
return new $baseType$$desc.dim$$desc.suffix$($desc.properties :{ property
    |$this$get$property.upperName$() $op$ $other$get$property.upperName$()}; separator=", "$);
>>

BinaryFunction(desc, op, this, other, baseType ="Vector") ::= <<
return new $baseType$$desc.dim$$desc.suffix$($desc.properties :{ property
    |$op$($this$get$property.upperName$(), $other$get$property.upperName$())}; separator=", "$);
>>

BinaryOperatorScalar(desc, op, this, scalar, baseType ="Vector") ::= <<
return new $baseType$$desc.dim$$desc.suffix$($desc.properties :{ property
    |($desc.type$)($this$get$property.upperName$() $op$ $scalar$)}; separator=", "$);
>>

InvLerp(desc, this="", other="other.", vLerp="vLerp.") ::= <<
//v12    = other.sub(this)
//v1Lerp = vLerp.sub(this)
//v12.proj( v1Lerp ) = v12.dot( v1Lerp ) / v12.getLength()

$desc.properties :{ property
    |double $property.name$1 = $other$get$property.upperName$() - $this$get$property.upperName$();}; separator="\n"$

$desc.properties :{ property
    |double $property.name$2 = $vLerp$get$property.upperName$() - $this$get$property.upperName$();}; separator="\n"$

return ($desc.properties :{ property |$property.name$1 * $property.name$2}; separator=" + "$) / Math.sqrt($desc.properties :{ property |$property.name$1 * $property.name$1}; separator=" + "$);
>>

Lineal(desc, this="", other="other.", ret = "Vector") ::= <<
return new $ret$$desc.dim$$desc.suffix$($desc.properties:{ property
    |($desc.type$)(alpha * $this$get$property.upperName$() + beta * $other$get$property.upperName$())}; separator=", "$);
>>

UnaryOperatorAndSet(desc, op, this) ::= <<
set($desc.properties :{ property
    |$op$ $this$get$property.upperName$()}; separator=", "$);
return this;
>>

UnaryFunctionAndSet(desc, op, this) ::= <<
set($desc.properties :{ property
    |$op$($this$get$property.upperName$())}; separator=", "$);
return this;
>>

BinaryOperatorAndSet(desc, op, this, other) ::= <<
set($desc.properties :{ property
    |$this$get$property.upperName$() $op$ $other$get$property.upperName$()}; separator=", "$);
return this;
>>

BinaryFunctionAndSet(desc, op, this, other) ::= <<
set($desc.properties :{ property
    |$op$($this$get$property.upperName$(), $other$get$property.upperName$())}; separator=", "$);
return this;
>>

BinaryOperatorScalarAndSet(desc, op, this, scalar) ::= <<
set($desc.properties :{ property
    |($desc.type$)($this$get$property.upperName$() $op$ $scalar$)}; separator=", "$);
return this;
>>

LinealAndSet(desc, this="", other="other.") ::= <<
set($desc.properties:{ property
    |($desc.type$)(alpha * $this$get$property.upperName$() + beta * $other$get$property.upperName$())}; separator=", "$);
return this;
>>



GetQuadrant(desc, this="") ::= <<
int v = 0;
int p = 1;
$desc.properties :{ property |
if ($this$get$property.upperName$() < 0) {
    v |= p;
\}
}; separator="        p <<= 1;\n"$
return v;
>>

GetLengthL1(desc, this="") ::= <<
return $desc.properties :{ property
    |Math.abs($this$get$property.upperName$())}; separator=" + "$;
>>

GetDistanceCuad(desc, this="", other="other.") ::= <<
return $desc.properties :{ property
    |square($other$get$property.upperName$() - $this$get$property.upperName$())}; separator=" + "$;
>>

GetDistanceL1(desc, this="", other="other.") ::= <<
return $desc.properties :{ property
    |Math.abs($other$get$property.upperName$() - $this$get$property.upperName$())}; separator=" + "$;
>>

ProjectTo(desc, this="", where="where.") ::= <<
double a = $desc.properties :{ property
    |$this$get$property.upperName$() * $where$get$property.upperName$()}; separator=" + "$;
double b = Math.sqrt($desc.properties :{ property
    |square($this$get$property.upperName$())}; separator=" + "$);
double c = a / b;
return new Point$desc.dim$$desc.suffix$($desc.properties :{ property
    |$where$get$property.upperName$() * c}; separator=", "$);
>>



Identity2(op, a) ::= <<$a$>>
UnaryOperator2(op, a) ::= <<$op$ $a$>>
UnaryMethod2(op, a) ::= <<$op$($a$)>>
Prefix2(op, a) ::= <<$op$$a$>>
Suffix2(op, a) ::= <<$a$$op$>>

Identity3(op, a, b) ::= <<$a$>>
UnaryOperator3(op, a, b) ::= <<$op$ $a$>>
UnaryMethod3(op, a, b) ::= <<$op$($a$)>>
BinaryOperator3(op, a, b) ::= <<$a$ $op$ $b$>>
BinaryMethod3(op, a, b) ::= <<$op$($a$, $b$)>>
Prefix3(op, a, b) ::= <<$op$$a$>>
Suffix3(op, a, b) ::= <<$a$$op$>>

Callback(desc, fun, op, filter1="Identity2", p1="", filter2="Identity2", p2="", separator=", ") ::= <<$desc.properties:{ property | $(fun)(op, (filter1)(p1, {get$property.upperName$()}), (filter2)(p2, {get$property.upperName$()}))$ }; separator=separator$>>
