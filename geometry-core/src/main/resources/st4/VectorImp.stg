delimiters "$", "$"

import "Common.stg"

VectorImp(desc) ::= <<
package $desc._package$;

import $desc.corePackage$.Tuple$desc.dim$;
import $desc.corePackage$.Vector$desc.dim$;

/**
 * Basic implementation of {@code Vector$desc.dim$\}.
 */
public class Vector$desc.dim$$desc.suffix$ extends Tuple$desc.dim$$desc.suffix$ implements Vector$desc.dim$ {

$VectorImp_Fields(desc)$

$VectorImp_Constructors(desc, {Vector$desc.dim$$desc.suffix$})$

$VectorImp_Private(desc)$

$VectorImp_Vector(desc)$
}
>>

VectorImp_2D(desc) ::= <<
    /**
     * This method evaluates the angle of {@code this} with respect to the X axis.
     * <p>
     * {@code
     * ^           __
     * |          _/| this
     * |        _/
     * |      _/
     * |    _/ __
     * |  _/   |\ angulo +
     * |_/       |
     * --+------------> X
     * origen      |
     * |   \_  |/  angulo -
     * |     \_|--
     * |       \_
     * |         \_
     * |           \|
     * v          --| this
     * }
     *
     * @return Angle.
     */
    public double getAngle() {
        return (double) Math.atan2(getY(), getX());
    }

    /**
     * This method evaluates the angle of {@code this} with respect to {@code other}. Angle in radians between [-PI, PI].
     * <ul>
     * <li>It is positive if the spin es CCW [0, PI].</li>
     * <li>It is negative if the spin is CW [-PI, 0].</li>
     * </ul>
     * <p>
     * {@code
     *               __
     *              _/| other
     *            _/
     *          _/
     *        _/ __
     *      _/   |\ angulo +
     *    _/       |
     *   +          |
     * origen      |
     *       \_   /
     *         \_/
     *           \_
     *             \_
     *               \|
     *              --| this
     * }
     *
     * @param other Vector.
     * @return Angle.
     */
    public double angleTo(Vector$desc.dim$$desc.suffix$ other) {
        // http://stackoverflow.com/questions/2150050/finding-signed-angle-between-vectors
        return Math.atan2(getX() * other.getY() - getY() * other.getX(),
                          getX() * other.getX() + getY() * other.getY());
    }

    /**
     * This method calculates the perpendicular vector to the right (Perp) of {@code this} vector.
     *
     * @return {@code (y, -x)}
     */
    public Vector$desc.dim$$desc.suffix$ getPerpRight() {
        return new Vector$desc.dim$$desc.suffix$(getY(), -getX());
    }

    /**
     * This method calculates the perpendicular vector to the left of {@code this} vector.
     *
     * @return {@code (-y, x)}
     */
    public Vector$desc.dim$$desc.suffix$ getPerpLeft() {
        return new Vector$desc.dim$$desc.suffix$(-getY(), getX());
    }

    /**
     * This method calculates the perpendicular unit vector to the right (UnitPerp) of {@code this} vector.
     *
     * @return {@code this.perpRight / this.length }
     */
    public Vector$desc.dim$$desc.suffix$ getUnitPerpRight() {
        return getPerpRight().getUnit();
    }

    /**
     * This method calculates the perpendicular unit vector to the left of {@code this} vector.
     *
     * @return {@code this.perpLeft / this.length}
     */
    public Vector$desc.dim$$desc.suffix$ getUnitPerpLeft() {
        return getPerpLeft().getUnit();
    }

    /**
     * This method calculates the dot product of {@code this} vector with the perpendicular vector of {@code v}.
     * <p>
     * {@code (x, y).dotPerp(V.x, V.y) = (x,y) . v.perpRight = x*V.y - y*V.x }
     * <p>
     * NOTA: it is similar to the cross product.
     */
    public double dotPerpRight(Vector$desc.dim$$desc.suffix$ other) {
        return getX() * other.getY() - getY() * other.getX();
    }

    /**
     * This method rotates {@code this} vector.
     *
     * @param rad Angle (radians).
     * @return Rotated vector.
     */
    public Vector$desc.dim$$desc.suffix$ rotate(double angle) {
        double s = Math.sin(rad);
        double c = Math.cos(rad);
        return new Vector$desc.dim$$desc.suffix$(($desc.type$)(getX() * c - getY() * s),
                            ($desc.type$)(getX() * s + getY() * c));
    }

    /**
     * This method rotates and scales {@code this} vector.
     *
     * @param rad Angle (radians).
     * @param len Scale.
     * @return Rotated vector.
     */
    public Vector2d rotateAndScale(double angle, double len) {
        double s = Math.sin(rad);
        double c = Math.cos(rad);
        return new Vector$desc.dim$$desc.suffix$(($desc.type$)(len*(getX() * c - getY() * s)),
                            ($desc.type$)(len*(getX() * s + getY() * c)));
    }
>>

VectorImp_Constructors(desc, className) ::= <<
    /**
     * Empty constructor.
     */
    public $className$() {
    }

    /**
     * This constructor sets the values of the ( $desc.properties :{ property | $property.upperName$}; separator=", "$ ) coordinates.
     *
     $desc.properties :{ property | * @param $property.name$ Value of the property $property.upperName$. }; separator="\n"$
     */
    public $className$($desc.properties :{ property | $property.type$ $property.name$}; separator=", "$) {
        super($desc.properties :{ property | $property.name$}; separator=", "$);
    }

    /**
     * Copy constructor.
     *
     * @param other Other tuple.
     */
    public $className$(Tuple$desc.dim$ other) {
        super(other);
    }
>>

VectorImp_Fields(desc) ::= <<
    /**
     * Zero vector: ($desc.properties :{ property | 0}; separator=", "$).
     */
    public static final Vector$desc.dim$$desc.suffix$ ZERO = new Vector$desc.dim$$desc.suffix$($desc.properties :{ property | 0}; separator=", "$);

    /**
     * One vector: ($desc.properties :{ property | 1}; separator=", "$).
     */
    public static final Vector$desc.dim$$desc.suffix$ ONE = new Vector$desc.dim$$desc.suffix$($desc.properties :{ property | 1}; separator=", "$);

$desc.properties :{ property |
    /**
     * Unit vector: $property.upperName$.
     */
    public static final Vector$desc.dim$$desc.suffix$ U$property.upperName$ = getUnit($property.index$);
}; separator="\n"$
>>

VectorImp_Private(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="private">
    private static Vector$desc.dim$$desc.suffix$ getUnit(int index) {
        return new Vector$desc.dim$$desc.suffix$($desc.properties :{ property | ((index == $property.index$) ? 1 : 0)}; separator=", "$);
    }

    private Tuple$desc.dim$_$desc.ctype$ toTuple(Tuple$desc.dim$ other) {
        if (other instanceof Tuple$desc.dim$_$desc.ctype$) {
            return (Tuple$desc.dim$_$desc.ctype$)other;
        }
        return null;
    }
//</editor-fold>
>>

VectorImp_Vector(desc) ::= <<
//<editor-fold defaultstate="collapsed" desc="Vector$desc.dim$">
    @Override
    public boolean isUnit() {
        return essence.util.math.doubles.MathUtils.epsilonEquals(getLength(), 1);
    }

    @Override
    public int getQuadrant() {
        $GetQuadrant(desc)$
    }

    @Override
    public double getLengthL1() {
        $GetLengthL1(desc)$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ add(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);

        $BinaryOperator(desc, "+", "", "_other.")$
    }

    public Vector$desc.dim$$desc.suffix$ add(Vector$desc.dim$$desc.suffix$ other) {
        $BinaryOperator(desc, "+", "", "other.")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ sub(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);

        $BinaryOperator(desc, "-", "", "_other.")$
    }

    public Vector$desc.dim$$desc.suffix$ sub(Vector$desc.dim$$desc.suffix$ other) {
        $BinaryOperator(desc, "-", "", "other.")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ simpleMul(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);

        $BinaryOperator(desc, "*", "", "_other.")$
    }

    public Vector$desc.dim$$desc.suffix$ simpleMul(Vector$desc.dim$$desc.suffix$ other) {
        $BinaryOperator(desc, "*", "", "other.")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ simpleDiv(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);

        $BinaryOperator(desc, "/", "", "_other.")$
    }

    public Vector$desc.dim$$desc.suffix$ simpleDiv(Vector$desc.dim$$desc.suffix$ other) {
        $BinaryOperator(desc, "/", "", "other.")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ mul(double v) {
        $BinaryOperatorScalar(desc, "*", "", "v", "Vector")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ div(double v) {
        $BinaryOperatorScalar(desc, "/", "", "v", "Vector")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ neg() {
        $UnaryOperator(desc, "-", "")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ abs() {
        $UnaryFunction(desc, "Math.abs", "")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ lerp(Vector$desc.dim$ other, double alpha) {
        return lineal(other, 1 - alpha, alpha);
    }

    public Vector$desc.dim$$desc.suffix$ lerp(Vector$desc.dim$$desc.suffix$ other, double alpha) {
        return lineal(other, 1 - alpha, alpha);
    }

    @Override
    public double invLerp(Vector$desc.dim$ other, Vector$desc.dim$ vLerp) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
        Tuple$desc.dim$_$desc.ctype$ _vLerp = toTuple(vLerp);

        $InvLerp(desc, "", "_other.", "_vLerp.")$
    }

    public double invLerp(Vector$desc.dim$$desc.suffix$ other, Vector$desc.dim$$desc.suffix$ vLerp) {
        $InvLerp(desc, "", "other.", "vLerp.")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ lineal(Vector$desc.dim$ other, double alpha, double beta) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);

        $Lineal(desc, "", "_other.", "Vector")$
    }

    public Vector$desc.dim$$desc.suffix$ lineal(Vector$desc.dim$$desc.suffix$ other, double alpha, double beta) {
        $Lineal(desc, "", "other.", "Vector")$
    }

    @Override
    public Vector$desc.dim$$desc.suffix$ getUnit() {
        double len = getLength();
        if (essence.util.math.doubles.MathUtils.epsilonZero(len)) {
            return Vector$desc.dim$$desc.suffix$.ZERO;
        }
        return div(len);
    }

    @Override
    public double dot(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
        return getX() * _other.getX() + getY() * _other.getY();
    }

    public double dot(Vector$desc.dim$$desc.suffix$ other) {
        return getX() * other.getX() + getY() * other.getY();
    }

    @Override
    public double cross(Vector$desc.dim$ other) {
        Tuple$desc.dim$_$desc.ctype$ _other = toTuple(other);
        return getX() * _other.getY() - getY() * _other.getX();
    }

    public double cross(Vector$desc.dim$$desc.suffix$ other) {
        return getX() * other.getY() - getY() * other.getX();
    }
//</editor-fold>
>>
