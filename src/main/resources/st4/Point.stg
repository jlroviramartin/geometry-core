delimiters "$", "$"

Point(desc) ::= <<
package $desc._package$;

public interface Point$desc.dim$ extends Tuple$desc.dim$ {

    /**
     * This method gets the quadrant/octant of {@code this} point.
     *
     * @return Quadrant of this point.
     */
    int getQuadrant();

    /**
     * This method gets the distance of {@code this} point to {@code other} point.
     *
     * @param other Other point.
     * @return Distance.
     */
    default double getDistance(Point$desc.dim$ other) {
        return Math.sqrt(getDistanceCuad(other));
    }

    /**
     * This method gets the squared distance of {@code this} point to {@code other} point.
     *
     * @param other Other point.
     * @return Squared distance.
     */
    double getDistanceCuad(Point$desc.dim$ other);

    /**
     * This method gets the L1 (Manhattan) distance of {@code this} point to {@code other} point.
     *
     * @param other Other point.
     * @return L1 (Manhattan) distance.
     */
    double getDistanceL1(Point$desc.dim$ other);

    /**
     * This method adds {@code this} point to {@code other} vector.
     *
     * @param other Other vector.
     * @return {@code result = this + other}
     */
    Point$desc.dim$ add(Vector$desc.dim$ other);

    /**
     * This method subs {@code this} point to {@code other} vector.
     *
     * @param other Other vector.
     * @return {@code result = this - other}
     */
    Point$desc.dim$ sub(Vector$desc.dim$ other);

    /**
     * This method gets the vector from {@code this} to {@code other} point.
     *
     * @param other Other point.
     * @return {@code result = other - this}
     */
    Vector$desc.dim$ vectorTo(Point$desc.dim$ other);

    /**
     * This method evaluates the linear interpolation of {@code this} point and {@code other} point at {@code alpha}.
     *
     * @param other Other point.
     * @param alpha Interpolation.
     * @return {@code this * alpha + other * (1 - alpha)}
     */
    default Point$desc.dim$ lerp(Point$desc.dim$ other, double alpha) {
        return lineal(other, 1 - alpha, alpha);
    }

    /**
     * This method evaluates the inverse of the linear interpolation of {@code this} point and {@code other} point at {@code pLerp}.
     *
     * @param other Other point.
     * @param pLerp Interpolated point.
     * @return {@code pLerp = this * result + other * (1 - result)}
     */
    double invLerp(Point$desc.dim$ other, Point$desc.dim$ pLerp);

    /**
     * This method evaluates the linear combination of {@code this} point and {@code other} point at {@code alpha} and {@code beta}.
     *
     * @param other Other point.
     * @param alpha Interpolation for {@code this}.
     * @param beta Interpolation for {@code other}.
     * @return {@code this * alpha + other * beta}
     */
    Point$desc.dim$ lineal(Point$desc.dim$ other, double alpha, double beta);
}
>>
